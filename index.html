<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Fruit Box (17x10)</title>
  <style>
    body {
      background: #eafedc !important; /* 연한 연두색 */
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      width: 100vw;
      box-sizing: border-box;
    }
    #game { margin: 20px auto; display: block; }
    #scoreboard { font-size: 20px; margin: 10px 0; }
    #groupcountboard { font-size: 18px; margin: 0 0 6px 0; color: #6f42c1; text-align: left; width: 850px; margin-left: auto; margin-right: auto; }
    #btns { margin-bottom: 10px; }
    .btn { padding: 5px 14px; font-size: 15px; margin-right: 8px; border-radius: 5px; border: 1px solid #888; background: #fff; cursor: pointer; }
    #timerbar-bg {
      width: 850px;
      height: 22px;
      background: #eee;
      border-radius: 12px;
      margin: 16px auto 6px auto;
      box-shadow: 0 1px 2px #ccc;
      position: relative;
    }
    #timerbar {
      height: 100%;
      background: linear-gradient(to right, #f00 60%, #ff0 100%);
      border-radius: 12px;
      transition: width 0.2s;
      position: absolute;
      left: 0; top: 0;
    }
    #timer-txt {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      text-align: center;
      line-height: 22px;
      font-weight: bold;
      color: #333;
      font-size: 16px;
      pointer-events: none;
    }
    #highscoreboard {
      font-size: 18px;
      margin: 0 0 8px 0;
      color: #1976d2;
      text-align: left;
      width: 850px;
      margin-left: auto;
      margin-right: auto;
    }
    #highscoreboard .btn {
      font-size:13px; margin-left:10px; padding: 3px 10px;
    }
    #gameover-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(70,70,70,0.60);
      display: none;
      z-index: 1000;
    }
    #gameover-modal {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 2px 18px #3336;
      width: 350px;
      padding: 40px 0 32px 0;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameover-modal .msg {
      color: #222;
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 1px 1px 8px #fff;
    }
    #gameover-modal .score {
      color: #333;
      font-size: 22px;
      margin-bottom: 8px;
      font-weight: normal;
    }
    #gameover-modal .highscore {
      color: #1976d2;
      font-size: 20px;
      margin-bottom: 16px;
      font-weight: normal;
    }
    #gameover-modal .reason {
      color: #777;
      font-size: 16px;
      margin-bottom: 15px;
      font-weight: normal;
    }
    #gameover-modal .btn {
      font-size: 18px;
      padding: 10px 30px;
      background: #f5f5f5;
      color: #f00;
      border-radius: 8px;
      border: 2px solid #f00;
      margin-top: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="timerbar-bg">
    <div id="timerbar"></div>
    <div id="timer-txt">02:00</div>
  </div>
  <div id="highscoreboard">
    최고점수: <span id="highscore">0</span>
    <button class="btn" onclick="resetHighScore()">최고점수 초기화</button>
  </div>
  <div id="scoreboard">점수: <span id="score">0</span></div>
  <div id="groupcountboard">가능한 조합: <span id="groupcount">0</span></div>
  <div id="btns">
    <button class="btn" onclick="initGame()">다시 시작</button>
  </div>
  <div id="gameover-overlay">
    <div id="gameover-modal">
      <div class="msg">게임 오버!</div>
      <div class="score"></div>
      <div class="highscore"></div>
      <div class="reason"></div>
      <button class="btn" onclick="initGame()">다시 시작</button>
    </div>
  </div>
  <canvas id="game"></canvas>
  <script>
    // 게임 설정
    const COLS = 17;
    const ROWS = 10;
    const CELL_SIZE = 50;
    const CANVAS_W = COLS * CELL_SIZE;
    const CANVAS_H = ROWS * CELL_SIZE;

    // 제한 시간 (초)
    const LIMIT_SEC = 120;
    let timer = LIMIT_SEC;
    let timerInterval = null;
    let gameActive = true;

    let apples = [];
    let selected = null;
    let score = 0;

    let highscore = Number(localStorage.getItem("fruitbox_highscore")) || 0;

    function updateHighscoreBoard() {
      document.getElementById("highscore").textContent = highscore;
    }

    function resetHighScore() {
      highscore = 0;
      localStorage.removeItem("fruitbox_highscore");
      updateHighscoreBoard();
    }

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    function drawAppleIcon(x, y, num) {
      const cx = x * CELL_SIZE + CELL_SIZE / 2;
      const cy = y * CELL_SIZE + CELL_SIZE / 2;
      const rX = CELL_SIZE * 0.38;
      const rY = CELL_SIZE * 0.33;
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, rX, rY, 0, 0, 2 * Math.PI);
      ctx.fillStyle = "#f00";
      ctx.shadowColor = "rgba(150,0,0,0.2)";
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.restore();
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy - rY);
      ctx.lineTo(cx + 4, cy - rY - 10);
      ctx.strokeStyle = "#7b3e00";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy - rY);
      ctx.quadraticCurveTo(cx - 10, cy - rY - 8, cx - 7, cy - rY - 1);
      ctx.fillStyle = "#1b8e2a";
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.2)";
      ctx.shadowBlur = 2;
      ctx.fillText(num, cx, cy);
      ctx.restore();
    }

    function initGame() {
      apples = [];
      for(let y=0; y<ROWS; y++) {
        let row = [];
        for(let x=0; x<COLS; x++) {
          row.push({num: randAppleNum(), gone: false});
        }
        apples.push(row);
      }
      score = 0;
      document.getElementById('score').textContent = score;
      selected = null;
      timer = LIMIT_SEC;
      gameActive = true;
      document.getElementById('gameover-overlay').style.display = "none";
      updateTimerBar();
      updateHighscoreBoard();
      updateGroupCountBoard();
      draw();
      if(timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    function randAppleNum() {
      return Math.floor(Math.random() * 9) + 1;
    }

    function draw() {
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

      ctx.strokeStyle = "#bbb";
      for(let x=0;x<=COLS;x++) {
        ctx.beginPath();
        ctx.moveTo(x*CELL_SIZE,0);
        ctx.lineTo(x*CELL_SIZE,CANVAS_H);
        ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++) {
        ctx.beginPath();
        ctx.moveTo(0,y*CELL_SIZE);
        ctx.lineTo(CANVAS_W,y*CELL_SIZE);
        ctx.stroke();
      }

      for(let y=0;y<ROWS;y++) {
        for(let x=0;x<COLS;x++) {
          let a = apples[y][x];
          if(a.gone) continue;
          drawAppleIcon(x, y, a.num);
        }
      }
      if(selected) {
        let {x1,y1,x2,y2,valid} = selected;
        let sx = Math.min(x1,x2)*CELL_SIZE;
        let sy = Math.min(y1,y2)*CELL_SIZE;
        let ex = (Math.max(x1,x2)+1)*CELL_SIZE;
        let ey = (Math.max(y1,y2)+1)*CELL_SIZE;
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = valid ? "#f00" : "#06f";
        ctx.fillRect(sx,sy,ex-sx,ey-sy);
        ctx.restore();
        ctx.lineWidth = 3;
        ctx.strokeStyle = valid ? "#f00" : "#06f";
        ctx.strokeRect(sx,sy,ex-sx,ey-sy);
      }
      updateGroupCountBoard();
    }

    function getApplesInRect(x1,y1,x2,y2) {
      let minX = Math.min(x1,x2);
      let maxX = Math.max(x1,x2);
      let minY = Math.min(y1,y2);
      let maxY = Math.max(y1,y2);
      let arr = [];
      for(let y=minY;y<=maxY;y++) {
        for(let x=minX;x<=maxX;x++) {
          if(apples[y][x] && !apples[y][x].gone) arr.push({x,y,num: apples[y][x].num});
        }
      }
      return arr;
    }

    function checkSum10(applesArr) {
      let sum = applesArr.reduce((acc,a)=>acc+a.num,0);
      return sum===10;
    }

    function countRemovableGroups() {
      let count = 0;
      for(let sy=0; sy<ROWS; sy++) {
        for(let sx=0; sx<COLS; sx++) {
          for(let ey=sy; ey<Math.min(ROWS, sy+3); ey++) {
            for(let ex=sx; ex<Math.min(COLS, sx+3); ex++) {
              let applesArr = getApplesInRect(sx, sy, ex, ey);
              if(applesArr.length>=2 && applesArr.length<=6 && checkSum10(applesArr)) {
                count++;
              }
            }
          }
        }
      }
      return count;
    }

    function updateGroupCountBoard() {
      document.getElementById("groupcount").textContent = countRemovableGroups();
    }

    function hasRemovableGroup() {
      return countRemovableGroups() > 0;
    }

    let dragging = false;
    let startCell = null;

    function eventToCell(e) {
      let rect = canvas.getBoundingClientRect();
      let x = (e.clientX - rect.left);
      let y = (e.clientY - rect.top);
      let cx = Math.floor(x/CELL_SIZE);
      let cy = Math.floor(y/CELL_SIZE);
      return {x: Math.max(0,Math.min(COLS-1,cx)), y: Math.max(0,Math.min(ROWS-1,cy))};
    }

    canvas.addEventListener('mousedown', e => {
      if(!gameActive) return;
      dragging = true;
      startCell = eventToCell(e);
      selected = {...startCell, x2: startCell.x, y2: startCell.y, valid:false};
      draw();
    });
    canvas.addEventListener('mousemove', e => {
      if(!dragging || !gameActive) return;
      let curr = eventToCell(e);
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      selected = {x1: startCell.x, y1: startCell.y, x2: curr.x, y2: curr.y, valid};
      draw();
    });
    canvas.addEventListener('mouseup', e => {
      if(!dragging || !gameActive) return;
      let curr = eventToCell(e);
      let applesArr = getApplesInRect(startCell.x, startCell.y, curr.x, curr.y);
      let valid = applesArr.length>0 && checkSum10(applesArr);
      if(valid) {
        applesArr.forEach(a=>{apples[a.y][a.x].gone=true;});
        score += applesArr.length;
        document.getElementById('score').textContent = score;
        selected = null;
        dragging = false;
        draw();
        updateGroupCountBoard();
        setTimeout(() => {
          if(!hasRemovableGroup()) endGame("지울 수 있는 사과가 없습니다.");
        }, 10);
        return;
      }
      selected = null;
      dragging = false;
      draw();
      updateGroupCountBoard();
      setTimeout(() => {
        if(!hasRemovableGroup()) endGame("지울 수 있는 사과가 없습니다.");
      }, 10);
    });

    function updateTimer() {
      timer--;
      if(timer < 0) {
        timer = 0;
        endGame("제한 시간이 끝났습니다.");
      }
      updateTimerBar();
    }

    function updateTimerBar() {
      const bar = document.getElementById('timerbar');
      const txt = document.getElementById('timer-txt');
      const percent = Math.max(0, timer) / LIMIT_SEC;
      bar.style.width = (percent*100*8.5) + "px";
      let mm = String(Math.floor(timer/60)).padStart(2,'0');
      let ss = String(timer%60).padStart(2,'0');
      txt.textContent = `${mm}:${ss}`;
    }

    function endGame(reasonText) {
      if(!gameActive) return;
      gameActive = false;
      if(score > highscore) {
        highscore = score;
        localStorage.setItem("fruitbox_highscore", String(highscore));
      }
      updateHighscoreBoard();
      const overlay = document.getElementById('gameover-overlay');
      overlay.style.display = "block";
      overlay.querySelector('.score').textContent = `최종 점수: ${score}점`;
      overlay.querySelector('.highscore').textContent = `최고점수: ${highscore}점`;
      overlay.querySelector('.reason').textContent = reasonText ? reasonText : "";
      if(timerInterval) clearInterval(timerInterval);
    }

    updateHighscoreBoard();
    initGame();
  </script>
</body>
</html>
